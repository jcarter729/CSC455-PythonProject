<!DOCTYPE html>
<html>
<head>
    <title>Two-Way Video with ICE</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            gap: 10px;
            background: #222;
        }
        video {
            width: 45%;
            border: 3px solid white;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <video id="localVideo" autoplay playsinline muted></video>
    <video id="remoteVideo" autoplay playsinline></video>

    <script>
        const localVideo = document.getElementById("localVideo");
        const remoteVideo = document.getElementById("remoteVideo");

        // Add a visible control so users explicitly start their camera
        const startBtn = document.createElement('button');
        startBtn.id = 'startBtn';
        startBtn.textContent = 'Start Camera & Connect';
        startBtn.style.position = 'fixed';
        startBtn.style.bottom = '20px';
        startBtn.style.left = '20px';
        startBtn.style.padding = '8px 12px';
        startBtn.style.fontSize = '14px';
        document.body.appendChild(startBtn);

        const statusSpan = document.createElement('span');
        statusSpan.id = 'status';
        statusSpan.style.position = 'fixed';
        statusSpan.style.bottom = '24px';
        statusSpan.style.left = '170px';
        statusSpan.style.color = 'lightgreen';
        document.body.appendChild(statusSpan);

        // === CONFIG ===
        const peerId = "peer2";        // Change to "peer2" on second laptop
        const remotePeerId = "peer1";  // Change to "peer1" on second laptop

        // Use a public STUN server to help with NAT traversal
        const pc = new RTCPeerConnection({
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        });

        // Store ICE candidates
        async function sendCandidate(candidate) {
            await fetch("/candidate", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ peer_id: peerId, candidate })
            });
        }

        async function getRemoteCandidates() {
            const res = await fetch(`/get_candidates/${remotePeerId}`);
            const data = await res.json();
            return data.candidates || [];
        }

        // Show remote video
        pc.ontrack = (event) => {
            remoteVideo.srcObject = event.streams[0];
        };

        // Send local ICE candidates to server
        pc.onicecandidate = (event) => {
            if (event.candidate) sendCandidate(event.candidate);
        };

        // When user clicks, request camera permission and start signaling
        startBtn.addEventListener('click', async () => {
            startBtn.disabled = true;
            statusSpan.textContent = 'Requesting camera...';
            try {
                const localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                localVideo.srcObject = localStream;
                localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
                statusSpan.textContent = 'Camera active — connecting...';
                await runSignaling();
            } catch (err) {
                console.error('getUserMedia failed:', err);
                statusSpan.textContent = 'Camera permission denied';
                startBtn.disabled = false;
            }
        });

        async function runSignaling() {
            // 1. Check for remote offer
            let remoteOffer = null;
            try {
                const res = await fetch(`/get_offer/${remotePeerId}`);
                remoteOffer = await res.json();
            } catch (e) {
                console.error('Failed to fetch remote offer:', e);
            }

            if (remoteOffer && remoteOffer.sdp) {
                // Remote peer has offer → create answer
                await pc.setRemoteDescription(remoteOffer);
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);

                // Send answer (flat form)
                await fetch("/answer", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ peer_id: peerId, sdp: answer.sdp, type: answer.type })
                });
            } else {
                // No offer → create offer
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);

                await fetch("/offer", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ peer_id: peerId, sdp: offer.sdp, type: offer.type })
                });
            }

            // 2. Poll for remote answer
            let remoteAnswer = null;
            while (!remoteAnswer || !remoteAnswer.sdp) {
                await new Promise(r => setTimeout(r, 1000));
                try {
                    const res = await fetch(`/get_answer/${remotePeerId}`);
                    remoteAnswer = await res.json();
                } catch (e) {
                    console.warn('Error polling for answer:', e);
                }
            }
            try {
                await pc.setRemoteDescription(remoteAnswer);
                statusSpan.textContent = 'Connected';
                console.log('✅ WebRTC connection established!');
            } catch (e) {
                console.error('Failed to set remote description:', e);
            }

            // 3. Poll for remote ICE candidates and add them
            setInterval(async () => {
                const candidates = await getRemoteCandidates();
                for (const c of candidates) {
                    try {
                        await pc.addIceCandidate(c);
                    } catch (e) {
                        console.warn("Failed to add ICE candidate:", e);
                    }
                }
            }, 1000);
        }
    </script>
</body>
</html>
